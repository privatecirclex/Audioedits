<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LyricsAI - Client-Side Sync Tool</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        brand: {
                            yellow: '#F59E0B',
                            orange: '#F97316',
                            red: '#EF4444',
                        }
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    }
                }
            }
        }
    </script>
    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #9ca3af; }

        /* Karaoke Active State Animation */
        .karaoke-line { transition: all 0.3s ease; opacity: 0.5; transform: scale(1); transform-origin: left center; }
        .karaoke-line.active { 
            opacity: 1; 
            transform: scale(1.02);
            background: linear-gradient(to right, #F59E0B, #EF4444);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 700;
        }

        /* Loader Animation */
        .loader-bar {
            background: linear-gradient(90deg, #F59E0B, #F97316, #EF4444);
            background-size: 200% 200%;
            animation: gradientMove 2s ease infinite;
        }
        @keyframes gradientMove { 
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        /* Fix for scroll areas */
        .scroll-container {
            scrollbar-gutter: stable;
        }

        /* Helper for drag events */
        .pointer-events-none-recursive * {
            pointer-events: none;
        }
    </style>
</head>
<body class="bg-white text-slate-800 font-sans h-screen flex flex-col overflow-hidden">

    <header class="flex-none h-16 border-b border-slate-100 flex items-center justify-between px-6 bg-white z-10">
        <div class="flex items-center gap-2 cursor-pointer" onclick="location.reload()">
            <i class="fa-solid fa-wave-square text-brand-orange text-xl"></i>
            <h1 class="text-xl font-bold tracking-tight text-slate-900">Lyrics<span class="text-transparent bg-clip-text bg-gradient-to-r from-brand-orange to-brand-red">AI</span></h1>
        </div>
        <div class="flex gap-2">
            <button id="resetBtn" class="hidden text-slate-500 px-4 py-2 hover:text-brand-red transition-colors font-medium text-sm">
                <i class="fa-solid fa-trash-can mr-1"></i> Reset
            </button>
            <button id="exportBtn" class="bg-gradient-to-r from-brand-yellow via-brand-orange to-brand-red text-white px-5 py-2 rounded-lg font-medium shadow-md shadow-orange-100 hover:shadow-lg hover:shadow-orange-200 transition-all transform hover:-translate-y-0.5 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                <i class="fa-solid fa-download mr-2"></i> Export .LRC
            </button>
        </div>
    </header>

    <main class="flex-1 flex flex-col relative overflow-hidden">
        
        <div id="uploadView" class="absolute inset-0 z-20 bg-white flex flex-col items-center justify-center p-6 transition-all duration-500">
            <div id="dropZone" class="w-full max-w-2xl border-2 border-dashed border-slate-300 rounded-2xl p-12 text-center hover:border-brand-orange hover:bg-orange-50 transition-colors cursor-pointer group pointer-events-none-recursive">
                <div class="w-16 h-16 bg-orange-100 text-brand-orange rounded-full flex items-center justify-center mx-auto mb-4 group-hover:scale-110 transition-transform">
                    <i class="fa-solid fa-cloud-upload-alt text-2xl"></i>
                </div>
                <h2 class="text-2xl font-bold text-slate-800 mb-2">Upload Audio</h2>
                <p class="text-slate-500 mb-6">Drag & drop your song (MP3, WAV) to start AI transcription.</p>
                <input type="file" id="fileInput" class="hidden" accept="audio/*">
                <button type="button" id="selectBtn" class="pointer-events-auto px-6 py-2 bg-white border border-slate-300 rounded-lg text-slate-700 font-medium hover:border-brand-orange hover:text-brand-orange transition-colors">
                    Select File
                </button>
            </div>

            <div id="progressContainer" class="hidden mt-8 w-full max-w-md">
                <div class="flex justify-between text-sm font-medium text-slate-600 mb-2">
                    <span id="statusText">Initializing AI Model...</span>
                    <span id="percentText">0%</span>
                </div>
                <div class="w-full bg-slate-100 rounded-full h-2.5 overflow-hidden">
                    <div id="progressBar" class="loader-bar h-2.5 rounded-full" style="width: 0%"></div>
                </div>
                <p class="text-xs text-slate-400 mt-4 text-center">First run downloads the model (~80MB). Processing happens entirely on your device.</p>
            </div>
        </div>

        <div id="workspaceView" class="flex-1 flex flex-col hidden opacity-0 transition-opacity duration-500 h-full">
            
            <div class="bg-white border-b border-slate-100 p-4 shadow-sm flex-none z-10">
                <div class="flex items-center justify-center gap-4 mb-4">
                    <button id="playPauseBtn" class="w-12 h-12 rounded-full bg-slate-900 text-white flex items-center justify-center hover:bg-slate-700 transition-colors focus:ring-2 focus:ring-brand-orange focus:ring-offset-2">
                        <i class="fa-solid fa-play"></i>
                    </button>
                    <div class="text-sm font-mono text-slate-500 bg-slate-50 px-3 py-1 rounded border border-slate-100" id="timeDisplay">00:00 / 00:00</div>
                </div>
                <div id="waveform" class="w-full"></div>
            </div>

            <div class="flex justify-center border-b border-slate-100 bg-white">
                <button data-tab="editor" class="tab-btn active px-6 py-3 text-sm font-medium border-b-2 border-brand-orange text-brand-orange transition-all outline-none">
                    <i class="fa-solid fa-pen-to-square mr-2"></i> Editor
                </button>
                <button data-tab="preview" class="tab-btn px-6 py-3 text-sm font-medium border-b-2 border-transparent text-slate-500 hover:text-slate-700 transition-all outline-none">
                    <i class="fa-solid fa-microphone-lines mr-2"></i> Karaoke Preview
                </button>
            </div>

            <div class="flex-1 relative bg-slate-50 overflow-hidden">
                <div id="editorView" class="absolute inset-0 overflow-y-auto p-4 pb-24 scroll-container">
                    <div id="transcriptList" class="max-w-4xl mx-auto space-y-3">
                        </div>
                    <div class="h-24"></div> </div>

                <div id="previewView" class="absolute inset-0 hidden bg-white flex flex-col items-center p-8 text-center overflow-y-auto scroll-container">
                    <div id="karaokeDisplay" class="space-y-8 max-w-3xl w-full py-20">
                         </div>
                    <div class="h-32"></div>
                </div>
            </div>
        </div>
    </main>

    <script type="module">
        import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.0';
        import WaveSurfer from 'https://unpkg.com/wavesurfer.js@7/dist/wavesurfer.esm.js';
        import RegionsPlugin from 'https://unpkg.com/wavesurfer.js@7/dist/plugins/regions.esm.js';

        // --- Configuration ---
        env.allowLocalModels = false;
        // env.useBrowserCache = true; // Optimization: Ensure caching is enabled
        const MODEL_NAME = 'Xenova/whisper-base';
        
        // --- State ---
        let wavesurfer = null;
        let wsRegions = null;
        let transcriptData = [];
        let transcriber = null; // Model singleton
        let isProcessing = false;
        let currentlyActiveLineIndex = -1;

        // --- DOM Elements ---
        const els = {
            dropZone: document.getElementById('dropZone'),
            fileInput: document.getElementById('fileInput'),
            selectBtn: document.getElementById('selectBtn'),
            uploadView: document.getElementById('uploadView'),
            workspaceView: document.getElementById('workspaceView'),
            progressContainer: document.getElementById('progressContainer'),
            progressBar: document.getElementById('progressBar'),
            statusText: document.getElementById('statusText'),
            percentText: document.getElementById('percentText'),
            waveform: document.getElementById('waveform'),
            playPauseBtn: document.getElementById('playPauseBtn'),
            timeDisplay: document.getElementById('timeDisplay'),
            transcriptList: document.getElementById('transcriptList'),
            karaokeDisplay: document.getElementById('karaokeDisplay'),
            tabBtns: document.querySelectorAll('.tab-btn'),
            editorView: document.getElementById('editorView'),
            previewView: document.getElementById('previewView'),
            exportBtn: document.getElementById('exportBtn'),
            resetBtn: document.getElementById('resetBtn')
        };

        // --- Initialization ---

        // File Selection Logic
        els.selectBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Stop bubble to dropZone
            els.fileInput.click();
        });

        // Drop Zone Interaction
        els.dropZone.addEventListener('click', () => els.fileInput.click());
        
        els.dropZone.addEventListener('dragover', (e) => { 
            e.preventDefault(); 
            els.dropZone.classList.add('border-brand-orange', 'bg-orange-50'); 
        });

        // Fixed: Use relatedTarget to prevent flicker when dragging over children
        els.dropZone.addEventListener('dragleave', (e) => {
            if (!els.dropZone.contains(e.relatedTarget)) {
                els.dropZone.classList.remove('border-brand-orange', 'bg-orange-50');
            }
        });

        els.dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            els.dropZone.classList.remove('border-brand-orange', 'bg-orange-50');
            if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
        });

        els.fileInput.addEventListener('change', (e) => {
            if (e.target.files.length) handleFile(e.target.files[0]);
            // Reset value so same file can be selected again if needed
            e.target.value = '';
        });

        // Tab Navigation
        els.tabBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                els.tabBtns.forEach(b => {
                    b.classList.remove('border-brand-orange', 'text-brand-orange', 'active');
                    b.classList.add('border-transparent', 'text-slate-500');
                });
                btn.classList.add('border-brand-orange', 'text-brand-orange', 'active');
                btn.classList.remove('border-transparent', 'text-slate-500');

                if (btn.dataset.tab === 'editor') {
                    els.editorView.classList.remove('hidden');
                    els.previewView.classList.add('hidden');
                } else {
                    els.editorView.classList.add('hidden');
                    els.previewView.classList.remove('hidden');
                    renderPreview();
                    // Trigger an immediate check in case audio is playing
                    if(wavesurfer) updatePreviewActiveState(wavesurfer.getCurrentTime());
                }
            });
        });

        els.playPauseBtn.addEventListener('click', () => {
            if (wavesurfer) wavesurfer.playPause();
        });
        
        els.exportBtn.addEventListener('click', exportLRC);
        
        els.resetBtn.addEventListener('click', () => {
            if(confirm("Start over with a new file?")) {
                location.reload();
            }
        });

        // Global Keydown
        window.addEventListener('keydown', (e) => {
            // Prevent spacebar scrolling, trigger play/pause instead
            if (e.code === 'Space' && e.target === document.body) {
                e.preventDefault();
                if (wavesurfer) wavesurfer.playPause();
            }
        });

        // --- Logic Functions ---

        function updateProgress(percent, message, isPulse = false) {
            const safePercent = Math.min(Math.max(percent, 0), 100);
            els.progressBar.style.width = `${safePercent}%`;
            els.percentText.innerText = `${Math.floor(safePercent)}%`;
            els.statusText.innerText = message;
            isPulse ? els.progressBar.classList.add('animate-pulse') : els.progressBar.classList.remove('animate-pulse');
        }

        async function handleFile(file) {
            if (isProcessing) return;
            isProcessing = true;

            // Reset State
            if (wavesurfer) {
                wavesurfer.destroy();
                wavesurfer = null;
            }
            wsRegions = null;
            transcriptData = [];
            els.transcriptList.innerHTML = '';
            els.karaokeDisplay.innerHTML = '';
            els.exportBtn.disabled = true;
            currentlyActiveLineIndex = -1;

            els.dropZone.classList.add('hidden');
            els.progressContainer.classList.remove('hidden');
            
            try {
                // 1. Initialize Visualizer
                updateProgress(5, "Loading Audio...");
                initWaveSurfer(file);

                // 2. Initialize Model (Singleton)
                if (!transcriber) {
                    transcriber = await pipeline('automatic-speech-recognition', MODEL_NAME, {
                        progress_callback: (data) => {
                            if (data.status === 'progress') {
                                const downloadPct = data.progress; // 0-100
                                const barWidth = 10 + (downloadPct * 0.7); // Map 0-100 to 10-80% of bar
                                updateProgress(barWidth, `Downloading AI Model... (${Math.floor(downloadPct)}%)`);
                            }
                            if (data.status === 'done') updateProgress(85, "Model Loaded!");
                        }
                    });
                }

                // 3. Prepare Audio for AI (Resampling)
                updateProgress(90, "Processing Audio Data...");
                const audioData = await readAudio(file);

                // 4. Run Inference
                updateProgress(95, "AI is transcribing lyrics...", true);
                
                // Slight delay to allow UI to render progress bar before heavy blocking calculation
                await new Promise(r => setTimeout(r, 100));

                const output = await transcriber(audioData, {
                    chunk_length_s: 30,
                    stride_length_s: 5,
                    return_timestamps: true,
                    language: 'en' // Default to english, or remove for auto-detect
                });

                // 5. Finalize
                processTranscription(output);
                
                updateProgress(100, "Ready!");
                els.exportBtn.disabled = false;
                els.resetBtn.classList.remove('hidden');

                // Transition to Workspace
                setTimeout(() => {
                    els.uploadView.classList.add('hidden');
                    els.workspaceView.classList.remove('hidden');
                    setTimeout(() => els.workspaceView.classList.remove('opacity-0'), 50);
                }, 500);

            } catch (err) {
                console.error(err);
                alert("An error occurred: " + err.message);
                // Reset UI on error
                els.progressContainer.classList.add('hidden');
                els.dropZone.classList.remove('hidden');
            } finally {
                isProcessing = false;
            }
        }

        function initWaveSurfer(file) {
            wavesurfer = WaveSurfer.create({
                container: els.waveform,
                waveColor: '#fed7aa', // Orange-200
                progressColor: '#ef4444', // Red-500
                cursorColor: '#f97316', // Orange-500
                barWidth: 2,
                barRadius: 3,
                height: 128,
                normalize: true,
                minPxPerSec: 100, // Better zooming
                autoScroll: true,
                autoCenter: true,
            });

            // Initialize Plugin
            wsRegions = wavesurfer.registerPlugin(RegionsPlugin.create());

            wavesurfer.loadBlob(file);

            wavesurfer.on('ready', () => {
                const duration = wavesurfer.getDuration();
                els.timeDisplay.innerText = `00:00 / ${formatTime(duration)}`;
            });

            wavesurfer.on('audioprocess', (time) => {
                const duration = wavesurfer.getDuration() || 0;
                els.timeDisplay.innerText = `${formatTime(time)} / ${formatTime(duration)}`;
                updatePreviewActiveState(time);
            });

            wavesurfer.on('play', () => els.playPauseBtn.innerHTML = '<i class="fa-solid fa-pause"></i>');
            wavesurfer.on('pause', () => els.playPauseBtn.innerHTML = '<i class="fa-solid fa-play"></i>');
            wavesurfer.on('finish', () => els.playPauseBtn.innerHTML = '<i class="fa-solid fa-replay"></i>');

            // Region Sync Logic
            wsRegions.on('region-updated', (region) => {
                const index = transcriptData.findIndex(t => t.regionId === region.id);
                if (index !== -1) {
                    transcriptData[index].start = region.start;
                    transcriptData[index].end = region.end;
                    
                    // Update DOM inputs only if they are not currently focused (prevent fighting the user)
                    const sInp = document.getElementById(`start-${index}`);
                    const eInp = document.getElementById(`end-${index}`);
                    
                    if (sInp && document.activeElement !== sInp) sInp.value = region.start.toFixed(2);
                    if (eInp && document.activeElement !== eInp) eInp.value = region.end.toFixed(2);
                }
            });

            wsRegions.on('region-clicked', (region, e) => {
                e.stopPropagation();
                // Play just this region
                region.play();
            });
        }

        function processTranscription(output) {
            const chunks = output.chunks || [];
            
            // Filter out empty or noise chunks
            const validChunks = chunks.filter(c => c.text && c.text.trim().length > 0);

            transcriptData = validChunks.map((chunk, i) => {
                let start = chunk.timestamp[0];
                let end = chunk.timestamp[1];

                // Logic fix: If end is null (common in Whisper), assume it ends at start of next chunk
                if (!end) {
                    if (i < validChunks.length - 1) {
                        end = validChunks[i+1].timestamp[0];
                        // Ensure minimum duration of 0.5s to be clickable
                        if(end - start < 0.5) end = start + 1.0; 
                    } else {
                        end = start + 3.0; // Default for last chunk
                    }
                }
                
                // Sanity check: Start cannot be after End
                if (start >= end) end = start + 1.0;

                const regionId = `region-${i}`;

                // Add to visualizer
                wsRegions.addRegion({
                    id: regionId,
                    start: start,
                    end: end,
                    content: '', // Can add labels if needed
                    color: 'rgba(249, 115, 22, 0.15)', // Brand Orange transparent
                    drag: true,
                    resize: true
                });

                return { id: i, regionId, start, end, text: chunk.text.trim() };
            });

            renderEditor();
        }

        function renderEditor() {
            els.transcriptList.innerHTML = '';
            
            if (transcriptData.length === 0) {
                els.transcriptList.innerHTML = `<div class="text-center text-slate-400 py-10">No lyrics detected.</div>`;
                return;
            }

            transcriptData.forEach((item, index) => {
                const row = document.createElement('div');
                row.className = "flex items-start md:items-center gap-3 bg-white p-3 rounded-lg border border-slate-200 shadow-sm hover:shadow-md hover:border-orange-200 transition-all group";
                row.innerHTML = `
                    <div class="flex flex-col gap-1 w-24 flex-none mt-1 md:mt-0">
                        <input type="number" step="0.1" id="start-${index}" class="text-xs bg-slate-50 border border-slate-200 rounded px-1 py-1 text-slate-600 focus:border-brand-orange focus:ring-1 focus:ring-brand-orange outline-none transition-colors" value="${item.start.toFixed(2)}">
                        <input type="number" step="0.1" id="end-${index}" class="text-xs bg-slate-50 border border-slate-200 rounded px-1 py-1 text-slate-600 focus:border-brand-orange focus:ring-1 focus:ring-brand-orange outline-none transition-colors" value="${item.end.toFixed(2)}">
                    </div>
                    <div class="flex-1 min-w-0">
                        <textarea id="text-${index}" rows="1" class="w-full text-base text-slate-800 font-medium border-b border-transparent focus:border-brand-orange bg-transparent outline-none resize-none overflow-hidden" oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px'">${item.text}</textarea>
                    </div>
                    <button class="w-8 h-8 rounded-full bg-orange-50 text-brand-orange flex items-center justify-center opacity-0 group-hover:opacity-100 hover:bg-brand-orange hover:text-white transition-all focus:opacity-100" onclick="window.playSegment('${item.regionId}')" title="Play Segment">
                        <i class="fa-solid fa-play text-xs"></i>
                    </button>
                `;
                els.transcriptList.appendChild(row);

                // Initialize textarea height
                const ta = row.querySelector(`#text-${index}`);
                if(ta) ta.style.height = ta.scrollHeight + 'px';

                // Event Listeners
                const sInp = row.querySelector(`#start-${index}`);
                const eInp = row.querySelector(`#end-${index}`);
                const tInp = row.querySelector(`#text-${index}`);

                // Debounce inputs to prevent UI jitter
                const updateRegion = () => {
                    let s = parseFloat(sInp.value);
                    let e = parseFloat(eInp.value);
                    
                    if (isNaN(s) || s < 0) s = 0;
                    if (isNaN(e) || e < s) e = s + 1;

                    transcriptData[index].start = s;
                    transcriptData[index].end = e;

                    const reg = wsRegions.getRegions().find(r => r.id === item.regionId);
                    if (reg) {
                        reg.setOptions({ start: s, end: e });
                    }
                };

                sInp.onchange = updateRegion;
                eInp.onchange = updateRegion;
                
                tInp.oninput = (e) => {
                    e.target.style.height = 'auto';
                    e.target.style.height = e.target.scrollHeight + 'px';
                    transcriptData[index].text = e.target.value;
                };
            });
        }

        function renderPreview() {
            els.karaokeDisplay.innerHTML = '';
            
            if (transcriptData.length === 0) {
                els.karaokeDisplay.innerHTML = `<div class="text-slate-400">Switch to editor to add lyrics</div>`;
                return;
            }

            transcriptData.forEach((item, index) => {
                const p = document.createElement('p');
                p.className = `karaoke-line text-2xl md:text-4xl text-slate-300 font-semibold cursor-pointer py-4 px-6 rounded-xl transition-all duration-300 select-none`;
                p.id = `karaoke-${index}`;
                p.innerText = item.text || "(Instrumental)";
                p.onclick = () => {
                    wavesurfer.setTime(item.start);
                    wavesurfer.play();
                };
                els.karaokeDisplay.appendChild(p);
            });
        }

        function updatePreviewActiveState(time) {
            if (els.previewView.classList.contains('hidden')) return;

            // Find current active index
            let activeIndex = -1;
            for (let i = 0; i < transcriptData.length; i++) {
                if (time >= transcriptData[i].start && time < transcriptData[i].end) {
                    activeIndex = i;
                    break;
                }
            }

            // Optimization: Only DOM update if index changed
            if (activeIndex !== currentlyActiveLineIndex) {
                
                // Remove active class from old
                if (currentlyActiveLineIndex !== -1) {
                    const oldEl = document.getElementById(`karaoke-${currentlyActiveLineIndex}`);
                    if (oldEl) oldEl.classList.remove('active');
                }

                // Add active class to new
                if (activeIndex !== -1) {
                    const newEl = document.getElementById(`karaoke-${activeIndex}`);
                    if (newEl) {
                        newEl.classList.add('active');
                        // Gentle scroll
                        newEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }

                currentlyActiveLineIndex = activeIndex;
            }
        }

        // --- Utils ---

        async function readAudio(file) {
            // Whisper models expect 16000Hz sampling rate
            const TARGET_SAMPLE_RATE = 16000;
            const buffer = await file.arrayBuffer();
            
            // Create context safely
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            const ctx = new AudioContext({ sampleRate: TARGET_SAMPLE_RATE });

            try {
                const decoded = await ctx.decodeAudioData(buffer);
                
                // If the browser didn't resample automatically, we might have an issue, 
                // but usually this works. We take the first channel (mono).
                const audio = decoded.getChannelData(0);
                return audio;
            } finally {
                // Important: Close context to free hardware resources
                await ctx.close();
            }
        }

        function formatTime(s) {
            if (isNaN(s)) return "00:00";
            const m = Math.floor(s / 60);
            const sec = Math.floor(s % 60);
            return `${m.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
        }

        function exportLRC() {
            if (!transcriptData.length) return;

            let content = '';
            transcriptData.forEach(line => {
                // LRC Format: [mm:ss.xx]
                const m = Math.floor(line.start / 60).toString().padStart(2, '0');
                const s = Math.floor(line.start % 60).toString().padStart(2, '0');
                
                // Fixed: milliseconds should be 2 digits (centiseconds)
                const val = (line.start % 1) * 100;
                const ms = Math.floor(val).toString().padStart(2, '0');
                
                content += `[${m}:${s}.${ms}]${line.text}\n`;
            });

            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `lyrics_sync.lrc`;
            document.body.appendChild(a); // Firefox requirement
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Exposed global for onclick handler in HTML string
        window.playSegment = (id) => {
            if (!wsRegions) return;
            const r = wsRegions.getRegions().find(reg => reg.id === id);
            if (r) r.play();
        };
    </script>
</body>
</html>
